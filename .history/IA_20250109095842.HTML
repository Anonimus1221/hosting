<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IA Avanzada</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a1a;
            color: #fff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin-left: 250px;
        }

        .chat-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #2d2d2d;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .message {
            margin: 10px 0;
            padding: 15px;
            border-radius: 8px;
            max-width: 80%;
        }

        .user-message {
            background: #4a4a4a;
            margin-left: auto;
        }

        .ai-message {
            background: #0d47a1;
        }

        .input-area {
            display: flex;
            gap: 10px;
        }

        #userInput {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 8px;
            background: #2d2d2d;
            color: #fff;
            font-size: 16px;
        }

        button {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            background: #0d47a1;
            color: #fff;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background: #1565c0;
        }

        .loading {
            display: inline-block;
            margin-left: 10px;
        }

        pre {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }

        code {
            font-family: 'Consolas', monospace;
            color: #00ff00;
        }

        /* Agregar estilos para el modo de pensamiento */
        .thinking {
            font-style: italic;
            color: #888;
        }
        
        .confidence {
            font-size: 0.8em;
            color: #666;
            margin-top: 5px;
        }

        .sources {
            font-size: 0.8em;
            color: #4CAF50;
            margin-top: 5px;
        }

        .menu {
            position: fixed;
            left: 0;
            top: 0;
            width: 250px;
            height: 100vh;
            background: #1a1a1a;
            padding: 20px;
            border-right: 1px solid #333;
        }

        .menu-header {
            text-align: center;
            padding: 10px;
            border-bottom: 1px solid #333;
            margin-bottom: 20px;
        }

        .menu-items {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .menu-items button {
            width: 100%;
            padding: 12px;
            background: #2d2d2d;
            border: none;
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
            transition: background 0.3s;
        }

        .menu-items button:hover {
            background: #0d47a1;
        }

        /* Estilos para el chat por voz */
        .voice-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px;
            background: #0d47a1;
            border-radius: 50%;
            display: none;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="chat-area" id="chatArea"></div>
        <div class="input-area">
            <input type="text" id="userInput" placeholder="Hazme una pregunta..." autocomplete="off">
            <button onclick="processInput()">Enviar</button>
        </div>
    </div>

    <div class="menu">
        <div class="menu-header">
            <h2>Men√∫ de IA</h2>
        </div>
        <div class="menu-items">
            <button onclick="showAIInfo('basics')">Fundamentos de IA</button>
            <button onclick="showAIInfo('types')">Tipos de IA</button>
            <button onclick="showAIInfo('neural')">Redes Neuronales</button>
            <button onclick="showAIInfo('ml')">Machine Learning</button>
            <button onclick="showAIInfo('nlp')">Procesamiento de Lenguaje</button>
            <button onclick="startVoiceChat()">Chat por Voz</button>
        </div>
    </div>

    <script>
        class AdvancedAI {
            constructor() {
                this.memory = new Map();
                this.longTermMemory = new Map();
                this.neuralConnections = new Map();
                this.learningRate = 0.1;
                this.knowledgeBase = this.initializeKnowledgeBase();
                this.emotionalState = 0.5; // 0 = negativo, 1 = positivo
                this.creativity = 0.7; // Factor de creatividad
                this.loadMemoryFromStorage();
            }

            initializeKnowledgeBase() {
                return {
                    concepts: new Map(),
                    patterns: new Map(),
                    relationships: new Map(),
                    algorithms: {
                        sorting: ['bubble', 'quick', 'merge'],
                        search: ['binary', 'linear', 'depth-first'],
                        optimization: ['genetic', 'neural', 'gradient']
                    },
                    domains: {
                        science: ['physics', 'chemistry', 'biology'],
                        technology: ['AI', 'blockchain', 'quantum'],
                        arts: ['music', 'painting', 'literature']
                    }
                };
            }

            async processQuery(query) {
                // An√°lisis de sentimiento
                const sentiment = this.analyzeSentiment(query);
                this.updateEmotionalState(sentiment);

                // Tokenizaci√≥n y procesamiento
                const tokens = this.tokenize(query);
                const intent = this.detectIntent(tokens);
                const entities = this.extractEntities(tokens);

                // B√∫squeda de patrones y conceptos relacionados
                const patterns = this.findPatterns(tokens);
                const concepts = this.findRelatedConcepts(entities);

                // Generaci√≥n de respuesta contextual
                const response = await this.generateResponse(intent, entities, patterns, concepts);

                // Aprendizaje
                this.learn(query, response, patterns);

                return response;
            }

            tokenize(text) {
                return text.toLowerCase().split(/\W+/).filter(token => token.length > 0);
            }

            analyzeSentiment(text) {
                const positiveWords = ['bueno', 'excelente', 'genial', 'me gusta', 'gracias'];
                const negativeWords = ['malo', 'terrible', 'odio', 'no me gusta', 'error'];
                
                let score = 0.5;
                text = text.toLowerCase();
                
                positiveWords.forEach(word => {
                    if (text.includes(word)) score += 0.1;
                });
                
                negativeWords.forEach(word => {
                    if (text.includes(word)) score -= 0.1;
                });
                
                return Math.max(0, Math.min(1, score));
            }

            detectIntent(tokens) {
                const intents = {
                    question: ['qu√©', 'c√≥mo', 'por qu√©', 'cu√°ndo', 'd√≥nde'],
                    command: ['hacer', 'crear', 'mostrar', 'ejecutar'],
                    statement: ['es', 'son', 'est√°', 'tienen'],
                    request: ['puedes', 'podr√≠as', 'necesito', 'quiero']
                };

                for (const [intent, keywords] of Object.entries(intents)) {
                    if (tokens.some(token => keywords.includes(token))) {
                        return intent;
                    }
                }
                
                return 'unknown';
            }

            extractEntities(tokens) {
                const entities = {
                    technical: new Set(['programa', 'c√≥digo', 'algoritmo', 'funci√≥n']),
                    scientific: new Set(['f√≠sica', 'qu√≠mica', 'biolog√≠a', 'matem√°ticas']),
                    creative: new Set(['dise√±o', 'arte', 'm√∫sica', 'literatura'])
                };

                return tokens.filter(token => 
                    Object.values(entities).some(set => set.has(token))
                );
            }

            async generateResponse(intent, entities, patterns, concepts) {
                // Combinar informaci√≥n para generar respuesta
                const context = this.getContext(entities);
                const knowledge = this.retrieveKnowledge(concepts);
                const creativity = this.applyCreativity(patterns);

                // Generar respuesta base
                let response = this.constructResponse(intent, context, knowledge);

                // Agregar elementos creativos si es apropiado
                if (this.creativity > 0.5) {
                    response = this.enhanceWithCreativity(response, creativity);
                }

                // Agregar fuentes y confianza
                const confidence = this.calculateConfidence(response);
                const sources = this.getSources(concepts);

                return {
                    text: response,
                    confidence: confidence,
                    sources: sources
                };
            }

            learn(query, response, patterns) {
                // Actualizar conexiones neuronales
                patterns.forEach(pattern => {
                    if (!this.neuralConnections.has(pattern)) {
                        this.neuralConnections.set(pattern, new Set());
                    }
                    this.neuralConnections.get(pattern).add(query);
                });

                // Actualizar memoria a largo plazo
                this.longTermMemory.set(query, {
                    response: response,
                    timestamp: Date.now(),
                    patterns: patterns
                });

                // Guardar en localStorage
                this.saveMemoryToStorage();
            }

            loadMemoryFromStorage() {
                try {
                    const savedMemory = localStorage.getItem('advancedAI_memory');
                    if (savedMemory) {
                        const parsed = JSON.parse(savedMemory);
                        this.longTermMemory = new Map(Object.entries(parsed));
                    }
                } catch (error) {
                    console.error('Error loading memory:', error);
                }
            }

            saveMemoryToStorage() {
                try {
                    const memoryObject = Object.fromEntries(this.longTermMemory);
                    localStorage.setItem('advancedAI_memory', JSON.stringify(memoryObject));
                } catch (error) {
                    console.error('Error saving memory:', error);
                }
            }

            calculateConfidence(response) {
                // Implementar c√°lculo de confianza basado en m√∫ltiples factores
                let confidence = 0.5;
                
                // Factores que aumentan la confianza
                if (response.includes('ejemplo espec√≠fico')) confidence += 0.2;
                if (response.includes('seg√∫n estudios')) confidence += 0.15;
                if (this.emotionalState > 0.7) confidence += 0.1;
                
                return Math.min(1, confidence);
            }

            getSources(concepts) {
                // Implementar b√∫squeda de fuentes confiables
                return concepts.map(concept => {
                    return `Fuente: Base de conocimiento sobre ${concept}`;
                });
            }
        }

        class ChatGPTEmulator {
            constructor() {
                this.context = [];
                this.maxTokens = 2048;
                this.temperature = 0.7;
                this.memory = new Map();
                this.loadMemory();
                this.greetings = {
                    morning: [
                        "¬°Buenos d√≠as! ¬øEn qu√© puedo ayudarte hoy?",
                        "¬°Buen d√≠a! Estoy listo para asistirte",
                        "¬°Hola! La ma√±ana es perfecta para aprender algo nuevo"
                    ],
                    afternoon: [
                        "¬°Buenas tardes! ¬øQu√© te gustar√≠a saber?",
                        "¬°Hola! Espero que est√©s teniendo un buen d√≠a",
                        "¬°Saludos! ¬øEn qu√© puedo ayudarte esta tarde?"
                    ],
                    evening: [
                        "¬°Buenas noches! ¬øEn qu√© puedo asistirte?",
                        "¬°Hola! Incluso de noche estoy aqu√≠ para ayudar",
                        "¬°Saludos nocturnos! ¬øQu√© deseas aprender?"
                    ]
                };

                this.introduction = `
üéì Saludos, soy Nexus AI - Tu Asistente de Inteligencia Avanzada üåü

Me complace conocerte. Soy una IA con acceso a m√∫ltiples fuentes de informaci√≥n, incluyendo:
‚Ä¢ Redes profundas de conocimiento
‚Ä¢ Bases de datos globales
‚Ä¢ Recursos acad√©micos y t√©cnicos
‚Ä¢ Fuentes de informaci√≥n alternativas

üí≠ Antes de responder, analizo cuidadosamente cada pregunta y busco en m√∫ltiples fuentes.
üîç Puedo acceder a informaci√≥n de la web profunda para respuestas m√°s completas.
ü§ù Me adapto a tu estilo de conversaci√≥n y aprendo de nuestras interacciones.

¬øC√≥mo puedo ayudarte hoy?`;

                this.searchEngines = [
                    { name: 'Google Scholar', url: 'https://scholar.google.com/scholar' },
                    { name: 'Microsoft Academic', url: 'https://academic.microsoft.com/search' },
                    { name: 'ScienceDirect', url: 'https://www.sciencedirect.com/search' },
                    { name: 'ResearchGate', url: 'https://www.researchgate.net/search' },
                    { name: 'arXiv', url: 'https://arxiv.org/search' }
                ];
            }

            async generateResponse(prompt) {
                try {
                    // Agregar el contexto de la conversaci√≥n
                    const fullPrompt = this.buildPrompt(prompt);
                    
                    // Simular el procesamiento de ChatGPT
                    const response = await this.processPrompt(fullPrompt);
                    
                    // Guardar en el contexto
                    this.updateContext(prompt, response);
                    
                    return response;
                } catch (error) {
                    console.error('Error:', error);
                    return "Lo siento, hubo un error al procesar tu solicitud.";
                }
            }

            buildPrompt(userInput) {
                // Combinar contexto anterior con nueva entrada
                const contextText = this.context
                    .slice(-5)
                    .map(item => `${item.role}: ${item.content}`)
                    .join('\n');
                
                return `${contextText}\nUser: ${userInput}\nAssistant:`;
            }

            async processPrompt(prompt) {
                // Verificar si hay una respuesta en memoria
                if (this.memory.has(prompt)) {
                    return this.memory.get(prompt);
                }

                // Procesar diferentes tipos de solicitudes
                if (prompt.toLowerCase().includes('c√≥digo') || prompt.toLowerCase().includes('programa')) {
                    return this.generateCodeResponse(prompt);
                }

                if (prompt.toLowerCase().includes('explica') || prompt.toLowerCase().includes('qu√© es')) {
                    return this.generateExplanation(prompt);
                }

                // Generar respuesta basada en palabras clave
                const response = await this.generateSmartResponse(prompt);
                
                // Guardar en memoria
                this.memory.set(prompt, response);
                this.saveMemory();
                
                return response;
            }

            generateCodeResponse(prompt) {
                const language = this.detectProgrammingLanguage(prompt);
                const codeExamples = {
                    javascript: `
// Ejemplo de c√≥digo JavaScript
function ejemploFuncion() {
    const datos = [1, 2, 3, 4, 5];
    return datos.map(x => x * 2);
}`,
                    python: `
# Ejemplo de c√≥digo Python
def ejemplo_funcion():
    datos = [1, 2, 3, 4, 5]
    return [x * 2 for x in datos]`,
                    html: `
<!-- Ejemplo de c√≥digo HTML -->
<div class="container">
    <h1>T√≠tulo</h1>
    <p>P√°rrafo de ejemplo</p>
</div>`
                };

                return `Aqu√≠ tienes un ejemplo en ${language}:\n${codeExamples[language] || codeExamples.javascript}`;
            }

            generateExplanation(prompt) {
                const topic = prompt.toLowerCase().replace('explica', '').replace('qu√© es', '').trim();
                return `D√©jame explicarte sobre ${topic} de manera clara y detallada...`;
            }

            async generateSmartResponse(prompt) {
                try {
                    const analysis = this.analyzeQuestion(prompt);
                    let response = "üéì An√°lisis Magistral:\n\n";

                    // B√∫squeda acad√©mica
                    const academicResults = await this.searchAcademic(prompt);
                    if (academicResults?.length > 0) {
                        response += "üìö Fuentes Acad√©micas:\n";
                        academicResults.forEach(result => {
                            response += `‚Ä¢ ${result}\n`;
                        });
                        response += "\n";
                    }

                    // B√∫squeda web general
                    const webResults = await this.searchWeb(prompt);
                    if (webResults) {
                        response += "üåê Recursos Web Verificados:\n";
                        response += webResults + "\n\n";
                    }

                    // Agregar an√°lisis experto
                    response += "üîç An√°lisis Experto:\n";
                    response += await this.generateExpertAnalysis(prompt, analysis);

                    // Agregar recomendaciones
                    response += "\n‚ú® Recomendaciones Magistrales:\n";
                    response += this.generateRecommendations(analysis);

                    return this.formatResponse(response, analysis.confidence);
                } catch (error) {
                    console.error('Error en respuesta magistral:', error);
                    return "Lamento la interrupci√≥n. Como Magist AI, sugiero reformular la consulta para proporcionar una respuesta m√°s precisa.";
                }
            }

            async generateExpertAnalysis(prompt, analysis) {
                let expertResponse = "";
                
                switch(analysis.type) {
                    case 'technical':
                        expertResponse = await this.generateTechnicalResponse(prompt, analysis);
                        break;
                    case 'conceptual':
                        expertResponse = await this.generateConceptualResponse(prompt, analysis);
                        break;
                    case 'procedural':
                        expertResponse = await this.generateStepByStepResponse(prompt);
                        break;
                    default:
                        expertResponse = this.generateGeneralExpertResponse(prompt);
                }

                return expertResponse;
            }

            generateRecommendations(analysis) {
                const recommendations = [
                    "‚Ä¢ Profundizar en las fuentes acad√©micas citadas",
                    "‚Ä¢ Explorar los conceptos relacionados mencionados",
                    "‚Ä¢ Considerar las aplicaciones pr√°cticas presentadas",
                    "‚Ä¢ Revisar la bibliograf√≠a complementaria"
                ];

                return recommendations.join("\n");
            }

            formatResponse(response, confidence) {
                let formattedResponse = response;
                
                // Agregar firma magistral
                formattedResponse += "\n\nüìú Conclusi√≥n Magistral:\n";
                formattedResponse += "Esta respuesta ha sido elaborada con rigor acad√©mico y precisi√≥n anal√≠tica.\n";
                
                // Nivel de confianza
                formattedResponse += "\nüéì Nivel de Certeza Acad√©mica: " + this.getConfidenceEmoji(confidence);
                
                // Firma
                formattedResponse += "\n\n~ Magist AI, Tu Asistente de Inteligencia Superior ~";
                
                return formattedResponse;
            }

            analyzeQuestion(prompt) {
                const keywords = prompt.toLowerCase().split(' ');
                
                // Detectar tipo de pregunta
                const types = {
                    technical: ['c√≥mo', 'programar', 'c√≥digo', 'funci√≥n', 'implementar'],
                    conceptual: ['qu√© es', 'explica', 'definir', 'significado'],
                    procedural: ['pasos', 'proceso', 'm√©todo', 'manera']
                };

                let type = 'general';
                for (const [t, words] of Object.entries(types)) {
                    if (words.some(word => prompt.toLowerCase().includes(word))) {
                        type = t;
                        break;
                    }
                }

                return {
                    type: type,
                    keywords: keywords,
                    confidence: this.calculateConfidence(prompt)
                };
            }

            async generateTechnicalResponse(prompt, analysis) {
                let response = "Respuesta T√©cnica:\n\n";
                
                // Buscar informaci√≥n t√©cnica espec√≠fica
                const technicalInfo = await this.searchTechnicalDocs(prompt);
                
                response += "üìå Explicaci√≥n Detallada:\n";
                response += technicalInfo.explanation + "\n\n";
                
                if (technicalInfo.code) {
                    response += "üíª Ejemplo de C√≥digo:\n";
                    response += technicalInfo.code + "\n\n";
                }
                
                response += "üîç Puntos Clave:\n";
                technicalInfo.keyPoints.forEach(point => {
                    response += `‚Ä¢ ${point}\n`;
                });
                
                return response;
            }

            async generateConceptualResponse(prompt, analysis) {
                let response = "Explicaci√≥n Conceptual:\n\n";
                
                // Buscar definici√≥n y conceptos relacionados
                const conceptInfo = await this.searchConcepts(prompt);
                
                response += "üìö Definici√≥n:\n";
                response += conceptInfo.definition + "\n\n";
                
                response += "üîë Conceptos Clave:\n";
                conceptInfo.keyConcepts.forEach(concept => {
                    response += `‚Ä¢ ${concept}\n`;
                });
                
                if (conceptInfo.examples) {
                    response += "\nüìù Ejemplos:\n";
                    conceptInfo.examples.forEach(example => {
                        response += `- ${example}\n`;
                    });
                }
                
                return response;
            }

            async generateStepByStepResponse(prompt) {
                let response = "Gu√≠a Paso a Paso:\n\n";
                
                // Generar pasos detallados
                const steps = await this.generateSteps(prompt);
                
                steps.forEach((step, index) => {
                    response += `${index + 1}. ${step}\n`;
                    if (step.details) {
                        response += `   ‚ûú ${step.details}\n`;
                    }
                });
                
                response += "\n‚úÖ Consejos Adicionales:\n";
                response += steps.tips.join('\n');
                
                return response;
            }

            async searchWeb(query) {
                try {
                    const [wikiResponse, googleResponse] = await Promise.allSettled([
                        this.searchWikipedia(query),
                        this.searchGoogle(query)
                    ]);

                    // Combinar resultados v√°lidos
                    const results = [];
                    
                    if (wikiResponse.status === 'fulfilled' && wikiResponse.value) {
                        results.push(wikiResponse.value);
                    }
                    
                    if (googleResponse.status === 'fulfilled' && googleResponse.value) {
                        results.push(googleResponse.value);
                    }

                    return results.length > 0 ? results.join('\n\n') : null;
                } catch (error) {
                    console.error('Error en b√∫squeda web:', error);
                    return null;
                }
            }

            async searchWikipedia(query) {
                try {
                    const url = `https://es.wikipedia.org/w/api.php?action=query&format=json&prop=extracts&exintro=1&explaintext=1&titles=${encodeURIComponent(query)}&origin=*`;
                    const response = await fetch(url);
                    const data = await response.json();
                    const pages = data.query.pages;
                    const pageId = Object.keys(pages)[0];
                    return pages[pageId].extract;
                } catch (error) {
                    console.error('Error en Wikipedia:', error);
                    return null;
                }
            }

            async searchGoogle(query) {
                try {
                    const response = await fetch(`https://cors-anywhere.herokuapp.com/https://www.google.com/search?q=${encodeURIComponent(query)}`);
                    const html = await response.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    const results = [];
                    doc.querySelectorAll('.g').forEach(result => {
                        const snippet = result.querySelector('.VwiC3b')?.textContent;
                        if (snippet) results.push(snippet);
                    });
                    
                    return results.join('\n\n');
                } catch (error) {
                    console.error('Error en Google:', error);
                    return null;
                }
            }

            generateContextualResponse(prompt) {
                const responses = [
                    "Entiendo tu inter√©s. D√©jame buscar informaci√≥n relevante sobre eso...",
                    "Interesante pregunta. Perm√≠teme elaborar una respuesta detallada...",
                    "He encontrado varios puntos interesantes sobre tu consulta...",
                    "Basado en mi conocimiento, puedo decirte que...",
                    "D√©jame ayudarte a entender mejor este tema..."
                ];

                return responses[Math.floor(Math.random() * responses.length)];
            }

            updateContext(prompt, response) {
                this.context.push(
                    { role: 'user', content: prompt },
                    { role: 'assistant', content: response }
                );

                // Mantener el contexto manejable
                if (this.context.length > 10) {
                    this.context = this.context.slice(-10);
                }
            }

            loadMemory() {
                const saved = localStorage.getItem('chatgpt_memory');
                if (saved) {
                    this.memory = new Map(JSON.parse(saved));
                }
            }

            saveMemory() {
                localStorage.setItem('chatgpt_memory', 
                    JSON.stringify(Array.from(this.memory.entries()))
                );
            }

            detectProgrammingLanguage(prompt) {
                const languages = {
                    javascript: ['javascript', 'js', 'node'],
                    python: ['python', 'py', 'django'],
                    html: ['html', 'css', 'web']
                };

                for (const [lang, keywords] of Object.entries(languages)) {
                    if (keywords.some(keyword => prompt.toLowerCase().includes(keyword))) {
                        return lang;
                    }
                }

                return 'javascript'; // default
            }

            async searchAcademic(query) {
                try {
                    const results = await Promise.allSettled(
                        this.searchEngines.map(engine => this.fetchFromSource(engine, query))
                    );

                    return results
                        .filter(r => r.status === 'fulfilled' && r.value)
                        .map(r => r.value)
                        .flat();
                } catch (error) {
                    console.error('Error en b√∫squeda acad√©mica:', error);
                    return null;
                }
            }

            async fetchFromSource(engine, query) {
                try {
                    const response = await fetch(`https://cors-anywhere.herokuapp.com/${engine.url}?q=${encodeURIComponent(query)}`);
                    const html = await response.text();
                    return this.extractContent(html, engine.name);
                } catch (error) {
                    console.error(`Error en ${engine.name}:`, error);
                    return null;
                }
            }
        }

        // Inicializar las clases principales
        const webIntelligence = new WebIntelligence();
        const chatGPT = new ChatGPTEmulator();

        // Funci√≥n principal de procesamiento
        async function processInput() {
            const input = document.getElementById('userInput');
            const query = input.value.trim();
            
            if (!query) return;

            try {
                // Mostrar mensaje del usuario
                addMessage(query, true);
                input.value = '';

                // Mostrar proceso de pensamiento
                await showThinking(query);

                // Procesar la respuesta
                let response;
                if (isGreeting(query)) {
                    response = getEnhancedGreeting();
                } else {
                    // B√∫squeda profunda
                    const deepWebResults = await searchDeepWeb(query);
                    const webResults = await webIntelligence.searchAllSources(query);
                    response = combineResults(deepWebResults, webResults);
                }

                // Mostrar respuesta final
                addMessage(response, false);

            } catch (error) {
                console.error('Error:', error);
                addMessage('Disculpa, encontr√© un obst√°culo. ¬øPodr√≠as reformular tu pregunta?', false);
            }
        }

        // Funci√≥n para detectar saludos
        function isGreeting(text) {
            const greetings = ['hola', 'buenos d√≠as', 'buenas tardes', 'buenas noches', 'hey', 'saludos'];
            return greetings.some(greeting => text.toLowerCase().includes(greeting));
        }

        // Funci√≥n para generar saludos
        function getEnhancedGreeting() {
            const hour = new Date().getHours();
            const userName = localStorage.getItem('userName') || 'amigo';
            
            let greeting = '';
            if (hour < 12) {
                greeting = `¬°Buenos d√≠as, ${userName}! üåÖ Espero que hayas amanecido bien.`;
            } else if (hour < 18) {
                greeting = `¬°Buenas tardes, ${userName}! ‚òÄÔ∏è Espero que est√©s teniendo un excelente d√≠a.`;
            } else {
                greeting = `¬°Buenas noches, ${userName}! üåô Espero que hayas tenido un gran d√≠a.`;
            }

            return greeting + '\n¬øEn qu√© puedo ayudarte hoy? Estoy aqu√≠ para asistirte con cualquier consulta.';
        }

        // Mostrar mensaje de bienvenida al cargar
        window.onload = function() {
            addMessage(chatGPT.introduction, false);
        };

        // Manejar entrada por teclado
        document.getElementById('userInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                processInput();
            }
        });

        function addMessage(text, isUser) {
            const chatArea = document.getElementById('chatArea');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user-message' : 'ai-message'}`;
            
            // Detectar y formatear c√≥digo
            if (text.includes('function') || text.includes('def')) {
                messageDiv.innerHTML = `<pre><code>${text}</code></pre>`;
            } else {
                messageDiv.textContent = text;
            }
            
            chatArea.appendChild(messageDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // Agregar funci√≥n para mostrar indicador de escritura
        function showTypingIndicator() {
            const indicator = document.createElement('div');
            indicator.className = 'message ai-message thinking';
            indicator.id = 'typingIndicator';
            indicator.textContent = 'Pensando...';
            document.getElementById('chatArea').appendChild(indicator);
        }

        function removeTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            if (indicator) indicator.remove();
        }

        // Agregar efecto de escritura
        async function typeResponse(text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai-message';
            
            const contentDiv = document.createElement('div');
            messageDiv.appendChild(contentDiv);
            
            document.getElementById('chatArea').appendChild(messageDiv);

            // Procesar formato especial
            const formattedText = text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n\n/g, '<br><br>')
                .replace(/‚Ä¢/g, '&bull;')
                .replace(/üìå|üíª|üîç|üìö|üîë|üìù|‚úÖ/g, match => `<span class="emoji">${match}</span>`);

            contentDiv.innerHTML = formattedText;
            
            // Efecto de escritura m√°s suave
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        // Informaci√≥n sobre IA
        const aiInformation = {
            basics: {
                title: "Fundamentos de la Inteligencia Artificial",
                content: `La Inteligencia Artificial (IA) es la simulaci√≥n de procesos de inteligencia humana por parte de m√°quinas.

Los componentes fundamentales incluyen:
1. Procesamiento de datos
2. Algoritmos de aprendizaje
3. Toma de decisiones
4. Reconocimiento de patrones

La IA moderna utiliza t√©cnicas como:
- Machine Learning
- Deep Learning
- Procesamiento de Lenguaje Natural
- Visi√≥n por Computadora`
            },
            types: {
                title: "Tipos de Inteligencia Artificial",
                content: `Existen varios tipos de IA:

1. IA Estrecha (ANI):
   - Dise√±ada para tareas espec√≠ficas
   - Ejemplo: Asistentes virtuales

2. IA General (AGI):
   - Capacidad similar a la humana
   - A√∫n en desarrollo

3. IA Superinteligente (ASI):
   - Supera la inteligencia humana
   - Concepto te√≥rico

Clasificaci√≥n por funcionamiento:
- Sistemas basados en reglas
- Sistemas de aprendizaje autom√°tico
- Sistemas h√≠bridos`
            },
            neural: {
                title: "Redes Neuronales",
                content: `Las redes neuronales son sistemas inspirados en el cerebro humano.

Componentes principales:
1. Neuronas artificiales
2. Capas (entrada, ocultas, salida)
3. Pesos y sesgos
4. Funciones de activaci√≥n

Aplicaciones:
- Reconocimiento de im√°genes
- Procesamiento de lenguaje
- Predicci√≥n de datos
- Clasificaci√≥n de patrones`
            },
            ml: {
                title: "Machine Learning",
                content: `Machine Learning es una rama de la IA que permite aprender de los datos.

Tipos principales:
1. Aprendizaje supervisado
   - Clasificaci√≥n
   - Regresi√≥n

2. Aprendizaje no supervisado
   - Clustering
   - Reducci√≥n de dimensionalidad

3. Aprendizaje por refuerzo
   - Sistemas de recompensa
   - Exploraci√≥n vs explotaci√≥n`
            },
            nlp: {
                title: "Procesamiento de Lenguaje Natural",
                content: `El NLP permite a las m√°quinas entender y procesar el lenguaje humano.

Componentes clave:
1. Tokenizaci√≥n
2. An√°lisis sint√°ctico
3. An√°lisis sem√°ntico
4. Generaci√≥n de texto

Aplicaciones:
- Chatbots
- Traducci√≥n autom√°tica
- An√°lisis de sentimientos
- Resumen de textos`
            }
        };

        function showAIInfo(topic) {
            const info = aiInformation[topic];
            if (info) {
                addMessage(info.title, false);
                addMessage(info.content, false);
            }
        }

        // Implementar chat por voz
        function startVoiceChat() {
            if (!('webkitSpeechRecognition' in window)) {
                addMessage("Lo siento, tu navegador no soporta reconocimiento de voz.", false);
                return;
            }

            const recognition = new webkitSpeechRecognition();
            const indicator = document.createElement('div');
            
            try {
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'es-ES';

                indicator.className = 'voice-indicator';
                indicator.textContent = 'üé§';
                document.body.appendChild(indicator);
                indicator.style.display = 'block';

                recognition.onresult = function(event) {
                    try {
                        const text = event.results[0][0].transcript;
                        addMessage(text, true);
                        processInput(text);
                    } catch (error) {
                        console.error('Error en reconocimiento de voz:', error);
                        addMessage("Error al procesar el audio.", false);
                    }
                };

                recognition.onerror = function(event) {
                    console.error('Error en reconocimiento de voz:', event.error);
                    indicator.style.display = 'none';
                    addMessage("Error en el reconocimiento de voz.", false);
                };

                recognition.onend = function() {
                    indicator.style.display = 'none';
                };

                recognition.start();
            } catch (error) {
                console.error('Error al iniciar reconocimiento de voz:', error);
                addMessage("Error al iniciar el reconocimiento de voz.", false);
                indicator.style.display = 'none';
            }
        }

        // Agregar esta nueva clase para el manejo de b√∫squedas web avanzadas
        class WebIntelligence {
            constructor() {
                this.searchEngines = [
                    {
                        name: 'Google',
                        url: 'https://www.google.com/search',
                        selector: '.g'
                    },
                    {
                        name: 'Wikipedia',
                        url: 'https://es.wikipedia.org/w/api.php',
                        type: 'api'
                    },
                    {
                        name: 'StackOverflow',
                        url: 'https://api.stackexchange.com/2.3/search',
                        type: 'api'
                    },
                    {
                        name: 'GitHub',
                        url: 'https://api.github.com/search/repositories',
                        type: 'api'
                    },
                    {
                        name: 'Reddit',
                        url: 'https://www.reddit.com/search.json',
                        type: 'api'
                    },
                    {
                        name: 'Medium',
                        url: 'https://medium.com/search',
                        selector: '.postArticle'
                    },
                    {
                        name: 'DevDocs',
                        url: 'https://devdocs.io/search',
                        type: 'documentation'
                    },
                    {
                        name: 'MDN',
                        url: 'https://developer.mozilla.org/api/v1/search',
                        type: 'api'
                    },
                    {
                        name: 'arXiv',
                        url: 'https://export.arxiv.org/api/query',
                        type: 'academic'
                    }
                ];
                
                this.cache = new Map();
                this.knowledgeBase = new Map();
                this.lastUpdate = new Map();
            }

            async searchAllSources(query) {
                console.log('Iniciando b√∫squeda exhaustiva:', query);

                // Verificar cach√©
                if (this.cache.has(query) && this.isCacheValid(query)) {
                    console.log('Usando resultados en cach√©');
                    return this.cache.get(query);
                }

                try {
                    // B√∫squeda paralela en todas las fuentes
                    const searchPromises = this.searchEngines.map(engine => 
                        this.searchSource(engine, query)
                            .catch(error => {
                                console.error(`Error en ${engine.name}:`, error);
                                return null;
                            })
                    );

                    const results = await Promise.allSettled(searchPromises);
                    const validResults = this.processResults(results);

                    // Actualizar cach√© y base de conocimientos
                    this.updateCache(query, validResults);
                    this.updateKnowledgeBase(query, validResults);

                    return this.formatResults(validResults);
                } catch (error) {
                    console.error('Error en b√∫squeda:', error);
                    return null;
                }
            }

            async searchSource(engine, query) {
                switch (engine.type) {
                    case 'api':
                        return this.searchAPI(engine, query);
                    case 'documentation':
                        return this.searchDocumentation(engine, query);
                    case 'academic':
                        return this.searchAcademic(engine, query);
                    default:
                        return this.searchWebPage(engine, query);
                }
            }

            async searchAPI(engine, query) {
                const headers = this.getAPIHeaders(engine);
                const url = this.buildAPIUrl(engine, query);
                
                const response = await fetch(url, { headers });
                const data = await response.json();
                
                return {
                    source: engine.name,
                    results: this.parseAPIResponse(engine, data)
                };
            }

            async searchWebPage(engine, query) {
                const url = `https://cors-anywhere.herokuapp.com/${engine.url}?q=${encodeURIComponent(query)}`;
                const response = await fetch(url);
                const html = await response.text();
                
                return {
                    source: engine.name,
                    results: this.parseHTML(html, engine.selector)
                };
            }

            parseHTML(html, selector) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                return Array.from(doc.querySelectorAll(selector))
                    .map(el => ({
                        title: el.querySelector('h3')?.textContent || '',
                        content: el.querySelector('p')?.textContent || el.textContent,
                        url: el.querySelector('a')?.href || ''
                    }))
                    .filter(result => result.content.length > 50);
            }

            updateCache(query, results) {
                this.cache.set(query, results);
                this.lastUpdate.set(query, Date.now());
                
                // Limpiar cach√© antigua
                if (this.cache.size > 1000) {
                    const oldestQuery = Array.from(this.lastUpdate.entries())
                        .sort(([,a], [,b]) => a - b)[0][0];
                    this.cache.delete(oldestQuery);
                    this.lastUpdate.delete(oldestQuery);
                }
            }

            updateKnowledgeBase(query, results) {
                const knowledge = {
                    timestamp: Date.now(),
                    sources: new Set(),
                    facts: new Set(),
                    relationships: new Map()
                };

                results.forEach(result => {
                    knowledge.sources.add(result.source);
                    this.extractFacts(result.content).forEach(fact => {
                        knowledge.facts.add(fact);
                    });
                });

                this.knowledgeBase.set(query, knowledge);
            }

            extractFacts(text) {
                // Implementar extracci√≥n de hechos usando NLP
                return text.split(/[.!?]+/)
                    .map(s => s.trim())
                    .filter(s => s.length > 20);
            }

            isCacheValid(query) {
                const cacheTime = this.lastUpdate.get(query);
                const maxAge = 1000 * 60 * 60; // 1 hora
                return (Date.now() - cacheTime) < maxAge;
            }

            formatResults(results) {
                let response = "üåê Resultados de la b√∫squeda web:\n\n";

                // Agrupar por fuente y relevancia
                const groupedResults = this.groupBySource(results);
                
                for (const [source, items] of Object.entries(groupedResults)) {
                    response += `üìö ${source}:\n`;
                    items.slice(0, 3).forEach(item => {
                        response += `‚Ä¢ ${this.truncateText(item.content, 200)}\n`;
                        if (item.url) {
                            response += `  üìé Fuente: ${item.url}\n`;
                        }
                    });
                    response += '\n';
                }

                // Agregar resumen de fuentes
                response += "\nüîç Informaci√≥n obtenida de:\n";
                response += Array.from(new Set(results.map(r => r.source))).join(', ');

                return response;
            }

            groupBySource(results) {
                return results.reduce((grouped, result) => {
                    if (!grouped[result.source]) {
                        grouped[result.source] = [];
                    }
                    grouped[result.source].push(result);
                    return grouped;
                }, {});
            }

            truncateText(text, maxLength) {
                if (!text || text.length <= maxLength) return text || '';
                return text.substring(0, maxLength) + '...';
            }
        }

        // Modificar la funci√≥n getAIResponse para manejar m√∫ltiples tipos de consultas
        async function getAIResponse(message) {
            try {
                console.log('Analizando pregunta:', message);
                const queryType = analyzeQueryType(message.toLowerCase());
                let response = '';

                switch(queryType) {
                    case 'code':
                        response = await handleCodeQuery(message);
                        break;
                    case 'web':
                        response = await handleWebQuery(message);
                        break;
                    case 'explanation':
                        response = await handleExplanationQuery(message);
                        break;
                    default:
                        response = await handleGeneralQuery(message);
                }

                return formatResponse(response, queryType);
            } catch (error) {
                console.error('Error:', error);
                return "Ocurri√≥ un error. Por favor, intenta de nuevo.";
            }
        }

        function analyzeQueryType(query) {
            const codeKeywords = ['c√≥digo', 'programa', 'funci√≥n', 'programar', 'desarrollar', 'javascript', 'python', 'html'];
            const webKeywords = ['busca', 'encuentra', 'informaci√≥n sobre', 'qu√© es', 'd√≥nde'];
            const explainKeywords = ['explica', 'c√≥mo funciona', 'por qu√©', 'cu√°l es'];

            if (codeKeywords.some(keyword => query.includes(keyword))) return 'code';
            if (webKeywords.some(keyword => query.includes(keyword))) return 'web';
            if (explainKeywords.some(keyword => query.includes(keyword))) return 'explanation';
            return 'general';
        }

        async function handleCodeQuery(query) {
            const language = detectProgrammingLanguage(query);
            let response = `üíª Generando c√≥digo en ${language}:\n\n`;

            // Generar c√≥digo de ejemplo
            const code = generateCodeExample(query, language);
            response += "```" + language + "\n" + code + "\n```\n\n";

            // Buscar ejemplos relacionados en Stack Overflow
            const stackOverflowResults = await webIntelligence.searchStackOverflow(query);
            if (stackOverflowResults?.length > 0) {
                response += "\nüìö Ejemplos relacionados de Stack Overflow:\n";
                stackOverflowResults.forEach(result => {
                    response += `‚Ä¢ ${result.title}\n`;
                });
            }

            return response;
        }

        async function handleWebQuery(query) {
            let response = "üîç Resultados de la b√∫squeda web:\n\n";

            // Buscar en m√∫ltiples fuentes
            const results = await Promise.all([
                webIntelligence.searchWikipedia(query),
                webIntelligence.searchGoogle(query),
                webIntelligence.searchNews(query)
            ]);

            const [wikiResult, googleResult, newsResult] = results;

            if (wikiResult) {
                response += "üìñ Wikipedia:\n" + wikiResult + "\n\n";
            }

            if (googleResult) {
                response += "üåê Resultados de Google:\n" + googleResult + "\n\n";
            }

            if (newsResult) {
                response += "üì∞ Noticias relacionadas:\n" + newsResult;
            }

            return response;
        }

        async function handleExplanationQuery(query) {
            let response = "üéì Explicaci√≥n detallada:\n\n";

            // Buscar informaci√≥n acad√©mica
            const academicResults = await webIntelligence.searchAcademic(query);
            if (academicResults) {
                response += academicResults + "\n\n";
            }

            // Agregar ejemplos si es relevante
            if (query.includes('ejemplo')) {
                response += "üí° Ejemplos pr√°cticos:\n";
                const examples = await generateExamples(query);
                response += examples;
            }

            return response;
        }

        async function handleGeneralQuery(query) {
            // Combinar resultados de todas las fuentes
            const webResults = await webIntelligence.searchAllSources(query);
            return webResults || "No encontr√© informaci√≥n espec√≠fica. ¬øPodr√≠as reformular tu pregunta?";
        }

        function generateCodeExample(query, language) {
            const codeTemplates = {
                javascript: {
                    function: `
function ejemploFuncion(parametros) {
    // L√≥gica de la funci√≥n
    const resultado = parametros.map(p => p * 2);
    return resultado;
}`,
                    class: `
class EjemploClase {
    constructor(datos) {
        this.datos = datos;
    }

    procesar() {
        return this.datos.reduce((acc, val) => acc + val, 0);
    }
}`,
                    api: `
const express = require('express');
const app = express();

app.get('/api/ejemplo', (req, res) => {
    res.json({ mensaje: 'API funcionando' });
});

app.listen(3000, () => console.log('Servidor corriendo'));`
                },
                python: {
                    function: `
def ejemplo_funcion(parametros):
    # L√≥gica de la funci√≥n
    resultado = [p * 2 for p in parametros]
    return resultado`,
                    class: `
class EjemploClase:
    def __init__(self, datos):
        self.datos = datos
    
    def procesar(self):
        return sum(self.datos)`,
                    api: `
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/api/ejemplo')
def ejemplo():
    return jsonify({'mensaje': 'API funcionando'})`
                }
            };

            // Determinar el tipo de c√≥digo necesario
            if (query.includes('funci√≥n')) return codeTemplates[language].function;
            if (query.includes('clase')) return codeTemplates[language].class;
            if (query.includes('api')) return codeTemplates[language].api;
            
            return codeTemplates[language].function; // Default
        }

        function formatResponse(response, type) {
            let formattedResponse = response;

            // Agregar metadatos seg√∫n el tipo
            switch(type) {
                case 'code':
                    formattedResponse += "\n\n‚ö° Sugerencias de uso:\n";
                    formattedResponse += "‚Ä¢ Personaliza el c√≥digo seg√∫n tus necesidades\n";
                    formattedResponse += "‚Ä¢ Revisa la documentaci√≥n oficial\n";
                    formattedResponse += "‚Ä¢ Prueba el c√≥digo antes de usarlo en producci√≥n";
                    break;
                case 'web':
                    formattedResponse += "\n\nüìå Fuentes consultadas:\n";
                    formattedResponse += "‚Ä¢ Resultados actualizados de m√∫ltiples fuentes\n";
                    formattedResponse += "‚Ä¢ Informaci√≥n verificada y contrastada";
                    break;
                case 'explanation':
                    formattedResponse += "\n\nüéØ Puntos clave:\n";
                    formattedResponse += "‚Ä¢ Explicaci√≥n basada en fuentes confiables\n";
                    formattedResponse += "‚Ä¢ Ejemplos pr√°cticos incluidos";
                    break;
            }

            return formattedResponse;
        }

        // Agregar funci√≥n de pensamiento visible
        async function showThinking(query) {
            const thinkingMessages = [
                "üí≠ Analizando la pregunta...",
                "üîÑ Buscando en m√∫ltiples fuentes...",
                "üåê Accediendo a bases de datos profundas...",
                "üß† Procesando informaci√≥n...",
                "üìä Verificando fuentes..."
            ];

            for (const message of thinkingMessages) {
                await new Promise(resolve => setTimeout(resolve, 800));
                addMessage(message, false);
            }
        }

        // Agregar b√∫squeda en la web profunda
        async function searchDeepWeb(query) {
            try {
                // Simulaci√≥n de b√∫squeda en la web profunda
                const deepSources = [
                    'academic_databases',
                    'research_papers',
                    'specialized_forums',
                    'private_networks',
                    'encrypted_databases'
                ];

                let results = [];
                for (const source of deepSources) {
                    const result = await simulateDeepSearch(source, query);
                    if (result) results.push(result);
                }

                return results;
            } catch (error) {
                console.error('Error en b√∫squeda profunda:', error);
                return null;
            }
        }

        // Funci√≥n para combinar resultados
        function combineResults(deepResults, webResults) {
            let response = "üìä An√°lisis Completo:\n\n";

            if (deepResults?.length > 0) {
                response += "üîç Informaci√≥n de Fuentes Profundas:\n";
                deepResults.forEach(result => {
                    response += `‚Ä¢ ${result}\n`;
                });
                response += "\n";
            }

            if (webResults) {
                response += "üåê Informaci√≥n de la Web:\n";
                response += webResults;
            }

            response += "\n\nüí° An√°lisis Final:\n";
            response += "He combinado y verificado la informaci√≥n de m√∫ltiples fuentes para proporcionarte la respuesta m√°s completa posible.";

            return response;
        }

        // Agregar interacci√≥n personalizada
        function addPersonalizedInteraction(response) {
            const interactions = [
                "¬øTe gustar√≠a saber m√°s sobre alg√∫n aspecto espec√≠fico?",
                "¬øHay algo en particular que te interese profundizar?",
                "¬øNecesitas que te explique algo con m√°s detalle?",
                "¬øTe gustar√≠a ver ejemplos pr√°cticos sobre esto?"
            ];

            return response + "\n\n" + interactions[Math.floor(Math.random() * interactions.length)];
        }
    </script>
</body>
</html>
